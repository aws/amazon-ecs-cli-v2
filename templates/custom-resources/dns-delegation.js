"use strict";const aws=require("aws-sdk");let defaultResponseURL,report=function(a,b,c,d,e,f){return new Promise((g,h)=>{const i=require("https"),{URL:j}=require("url");var k=JSON.stringify({Status:c,Reason:f,PhysicalResourceId:d||b.logStreamName,StackId:a.StackId,RequestId:a.RequestId,LogicalResourceId:a.LogicalResourceId,Data:e});const l=new j(a.ResponseURL||defaultResponseURL),m={hostname:l.hostname,port:443,path:l.pathname+l.search,method:"PUT",headers:{"Content-Type":"","Content-Length":k.length}};i.request(m).on("error",h).on("response",a=>{a.resume(),400<=a.statusCode?h(new Error(`Server returned error ${a.statusCode}: ${a.statusMessage}`)):g()}).end(k,"utf8")})};const createSubdomainInRoot=async function(a,b,c,d,e){const f=new aws.Route53({credentials:new aws.ChainableTemporaryCredentials({params:{RoleArn:e},masterCredentials:new aws.EnvironmentCredentials("AWS")})}),g=await f.listHostedZonesByName({DNSName:b}).promise();if(!g.HostedZones||0==g.HostedZones.length)throw new Error(`Couldn't find any hostedzones with DNS name ${b}. Request ${a}`);const h=g.HostedZones[0],i=h.Id.split("/").pop(),j=await f.changeResourceRecordSets({ChangeBatch:{Changes:[recordChangeAction("UPSERT",c,"NS",d.map(a=>({Value:a})))]},HostedZoneId:i}).promise();return console.log(`Created recordset in hostedzone ${i} for ${c}`),await waitForRecordSetChange(f,j.ChangeInfo.Id),c},deleteSubdomainInRoot=async function(a,b,c,d){const e=new aws.Route53({credentials:new aws.ChainableTemporaryCredentials({params:{RoleArn:d},masterCredentials:new aws.EnvironmentCredentials("AWS")})}),f=await e.listHostedZonesByName({DNSName:b}).promise();if(!f.HostedZones||0==f.HostedZones.length)throw new Error(`Couldn't find any hostedzones with DNS name ${b}. Request ${a}`);const g=f.HostedZones[0],h=g.Id.split("/").pop(),i=await e.listResourceRecordSets({HostedZoneId:h,MaxItems:"1",StartRecordName:c,StartRecordType:"NS"}).promise();if(!i.ResourceRecordSets||0==i.ResourceRecordSets)return c;const j=i.ResourceRecordSets[0];if(`${c}.`!==j.Name||"NS"!==j.Type)return c;console.log(`Deleting recordset ${j.Name}`);const k=await e.changeResourceRecordSets({ChangeBatch:{Changes:[recordChangeAction("DELETE",c,"NS",j.ResourceRecords)]},HostedZoneId:h}).promise();return await waitForRecordSetChange(e,k.ChangeInfo.Id),c},recordChangeAction=function(a,b,c,d){return{Action:a,ResourceRecordSet:{Name:b,Type:c,TTL:60,ResourceRecords:d}}},waitForRecordSetChange=function(a,b){return a.waitFor("resourceRecordSetsChanged",{$waiter:{delay:30,maxAttempts:10},Id:b}).promise()};exports.domainDelegationHandler=async function(a,b){var c,d={};try{switch(a.RequestType){case"Create":case"Update":const b=await createSubdomainInRoot(a.RequestId,a.ResourceProperties.DomainName,a.ResourceProperties.SubdomainName,a.ResourceProperties.NameServers,a.ResourceProperties.RootDNSRole);d.Arn=c=b;break;case"Delete":await deleteSubdomainInRoot(a.RequestId,a.ResourceProperties.DomainName,a.ResourceProperties.SubdomainName,a.ResourceProperties.RootDNSRole),c=a.PhysicalResourceId;break;default:throw new Error(`Unsupported request type ${a.RequestType}`);}await report(a,b,"SUCCESS",c,d)}catch(d){console.log(`Caught error ${d}.`),console.log(d),await report(a,b,"FAILED",c,null,d.message)}},exports.withDefaultResponseURL=function(a){defaultResponseURL=a};